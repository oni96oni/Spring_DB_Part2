스프링 트랜잭션 전파 2 - 활용
    트랜잭션 전파 활용 1 - 예제 프로젝트 시작

        JPA사용을 위해서는 기본생성자 반드시 필요!

        JPA의 모든 변경은 트랜잭션 안에서 이루어져야한다.

    트랜잭션 전파 활용 2 - 커밋, 롤백
        트랜잭션 AOP도 결국 내부에서는 트래잭션 매니저를 사용하게 된다.

    트랜잭션 전파 활용 3 - 단일 트랜잭션
        트랜잭션을 걸어주는 부분에서 문제해결을 위해 트랜잭션 전파가 필요하다!
        전파가 없으면 메소드를 각각 따로 만들어야 했을것!

    트랜잭션 전파 활용 4 - 전파 커밋
        @Transactional은 기본으로 REQUIRED 라는 전파옵션을 사용
            기존 트랜잭션이 없으면 트랜잭션을 생성하고, 기존 트랜잭션이 있으면 기존트랜잭션에 참여!
            참여한다는것은 기존 트랜잭션을 그대로 따른다 -> 같은 동기화 커넥션을 사용한다.

    트랜잭션 전파 활용 5 - 전파 롤백
        로그 리포지토리 예외 -> 전체 트랜잭션 롤백되는 경우
        로그예외라고 넘겼으니 런타임 예외 발생

        해당 논리 트랜잭션에서 예외 발생! MemberService로 예외를 던진다.
        내부 트랜잭션 롤백이므로 물리(전체) 롤백한다! 이런경우는 rollbackOnly 설정은 참고하지 않는다.

        비록 논리트랜잭션 하나가 성공했어도 전체트랜잭션상에서 롤백되는게 있으므로 전체 롤백이 되는것이 타당하다!

    트랜잭션 전파 활용 6 - 복구 REQUIRED
        ★★★ 실무에서도 중요!

        논리트랜잭션에서 타고올라온 에러를 본 트랜잭션에서 잡았을때 이런경우는 어떻게 되는가?

        내부 트랜잭션에서 예외가 발생해서 rollbackOnly를 표시했으므로, 외부 트랜잭션에서 예외를 처리했다 하더라도
        결국에는 롤백이된다!

        예외발생 -> AOP Proxy에서 트랜잭션 매니저에 롤백을 요청! 트랜잭션 매니저가 트랜잭션 동기화 매니저에
        rollbackOnly=true 표시를 남긴다.

        외부 트랜잭션 매니저에서 커밋, 롤백을 할 때 트랜잭션 동기화 매니저를 확인해서 rollbackOnly를 확인해서
        true값이면 결국 롤백한다!

    트랜잭션 전파 활용 7 - 복구 REQUIRES_NEW
        회원가입을 시도한 로그를 남기는데 실패하더라도 회원 가입은 성공시켜야 한다면?
        회원가입은 REQUIRED로 하고, 로그는 REQUIRES_NEW로 하면 된다.

        로그 트랜잭션은 물리 트랜잭션 자체가 분리! 즉 신규트랜잭션이 되므로 rollbackOnly 표시가 되지 않는다.
        예외가 나가면 기존의 트랜잭션에 논리구조상 예외를 던지긴 한다. 이때는 잘 처리하면 ok.

        결과적으로 회원 데이터는 저장, 로그 데이터만 롤백

        주의!
        REQUIRES_NEW를 사용하면 하나의 HTTP 요청에 2개의 DB 커넥션을 사용하게된다 -> 성능 문제!
        구조를 변경하는 방법도 존재!
        보통 REQUIRES_NEW를 사용하지 않고 문제를 해결할 수 있는 단순한 방법이 있다면, 그 방법을 선택하는 것이 더 좋다.

    정리
        하나의 트랜잭션은 하나의 DB 커넥션을 사용
        논리 상 연계된 구조에서 원하는 메서드만 따로 뽑아서 트랜잭션을 사용하고 싶다면 전파옵션을 사용해야한다.

        실제 커넥션을 사용하는 트랜잭션을 물리 트랜잭션이라고 부른다.

