스프링 트랜잭션 전파1 - 기본
    스프링 트랜잭션 전파 1 - 커밋, 롤백
        트랜잭션이 둘 이상있을떄 어떻게 동작하는가???

        스프링 전파란(propagation)???

    스프링 트랜잭션 전파 2 - 트랜잭션 두 번 사용
        같은 커넥션을 사용중! 커넥션 풀때문에!

        하지만 둘은 완전히 다른 커넥션으로 인지하는 것이 맞다.

    스프링 트랜잭션 전파 3 - 전파 기본
        트랜잭션이 이미 진행중인데 추가로 트랜잭션을 중첩해서 실행하면 어떻게 동작해야할까를 결정하는 것이 트랜잭션 전파!

        물리 트랜잭션 : 우리가 이해하는 실제 데이터베이스에 적용되는 트랜잭션을 뜻한다.
            실제 커밋, 롤백하는 단위
        논리 트랜잭션 : 하나의 물리 트랜잭션으로 묶인다.

        하나의 물리 트랜잭션 안에 여러개의 논리 트랜잭션이 있는 그림

        ★★원칙!
        모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.
        하나의 논리 트랜잭션이라도 롤백된다면 물리 트랜잭션이 롤백된다.

    스프링 트랜잭션 전파 4 - 전파 예제
        처음 수행된 트랜잭션 - 외부 트랜잭션은 신규 트랜잭션이 된다.(isNewTransaction=true)

        내부 트랜잭션이 외부 트랜잭션에 참여한다는 뜻은 내부 트랜잭션이 외부 트랜잭션을 그대로 이어 받아서 따른다는 뜻이다.

        하나의 커넥션에 커밋은 한번만 호출 가능! 어떻게 커밋이 두번 이루어졌을까?

        외부 트랜잭션 내부 트랜잭션을 어떻게 묶어서 하나의 물리 트랜잭션으로 만드는걸까???

        내부 트랜잭션 커밋에서는 아무 일도 안한다!!!!!!!!!!!

        내부 트랜잭션이 실제 물리 트랜잭션을 커밋하면 트랜잭션이 끝나버린다 따라서 내부 트랜잭션은 db커넥션을 통한
        물리 트랜잭션을 커밋하지 않는다.

        요청 흐름
        1. txManager.getTransaction() 호출로 외부 트랜잭션 시작
        2. 트랜잭션 매니저는 데이터 소스를 통해 커넥션을 생성
        3. 생성한 커넥션을 수동커밋모드로 설정 - 물리 트랜잭션 시작
        4. 트랜잭션 매니저는 트랜잭션 동기화 매니저에 커넥션을 보관한다.
        5. 여기에서 신규 트랜잭션의 여부가 담겨져 있다 신규 트랜잭션 true값을 가짐
        6. 로직1이 사용 커넥션이 필요하면 트랜잭션 동기화 매니저를 통해 트랜잭션이 적용된 커넥션을 획득해서 사용
        7. txManager.getTransaction()을 호출 내부 트랜잭션 시작
        8. 트랜잭션 매니저는 트랜잭션 동기화 매니저를 통해서 기존 트랜잭션이 존재하는지 확인
        9. 기존 트랜잭션이 존재하므로 기존 트랜잭션에 참여 -> 아무것도 하지 않을거라는 뜻! 참여한다는 로그 하나만 띄운다.
        10. 여기서 isNewTransaction은 false값을 가짐
        11. 로직2가 사용, 커넥션이 필요한 경우 트랜잭션 동기화 매니저를 통해 외부 트랜잭션이 보관한 커넥션을 획득해서 사용
        12. 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋
        13. isNewTransaction이 false이므로 트랜잭션 동기화 매니저는 실제 커밋을 하지 않는다.
        14. 로직1이 끝나고 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋
        15. 신규 트랜잭션이므로 실제 커밋 호출하고 끝

        외부에 맡기는 것이 참여의 뜻!

        트랜잭션 매니저에 커밋한다고 해서 실제 커넥션에 무조건 커밋하지는 않는다!

    스프링 트랜잭션 전파 5 - 외부 롤백
        논리 트랜잭션 중 하나라도 롤백이면 전 체 롤 백 !

        신규 트랜잭션에서 롤백을 호출! -> 트랜잭션 매니저는 db 커넥션에 실제 롤백을 호출한다.

    스프링 트랜잭션 전파 6 - 내부 롤백
        이번엔 내부트랜잭션 롤백 -> 하지만 내부 트랜잭션은 물리트랜잭션에 영향을 주지 않는다고 했다.

        외부 트랜잭션은 커밋해버린다.

        원칙 : 모든 논리 트랜잭션이 다 커밋되어야 커밋! 하나라도 롤백되면 전체 롤백!

        내부 트랜잭션을 롤백하면 실제 물리 트랜잭션은 롤백하지 않는다. 대신에! 기존 트랜잭션을 롤백 전용으로 표시한다.
        외부 트랜잭션을 커밋해도 롤백 전용 표시가 되어있으므로 커밋을 못해! 따라서 물리 트랜잭션을 롤백한다.

        트랜잭션 매니저는 롤백 시점에 신규 트랜잭션 여부에 따라 다르게 작동한다.
        신규 트랜잭션이 아니기 때문에 실제 롤백을 호출하지 않는다! 아직 트랜잭션이 끝난것이 아니기 때문에 실제 롤백을
        호출해서는 안된다.
        물리 트랜잭션은 외부 트랜잭션을 종료할 때 까지 이어져야 한다.

        트랜잭션 매니저는 커밋 시점에 외부 트랜잭션을 받았으므로 실제 커넥션을 가져와서 커밋을 호출하는데
        이때 트랜잭션 동기화 매니저에 롤백 전용 표시가 있는지 확인해서 롤백 표시가 있으면 물리 트랜잭션을 커밋하는 것이 아니라 롤백한다.

        논리 트랜잭션 중 하나라도 롤백 -> 물리 트랜잭션 롤백

        이렇게 기대한 결과가 다른 경우 에러를 발생시켜주는 것이 좋은 개발!

    스프링 트랜잭션 전파 7 - REQUIRES_NEW
        내부와 외부 트랜잭션을 완전히 분리해서 사용하는 방법!

        물리 트랜잭션을 분리하려면 내부 트랜잭션(다음 트랜잭션)을 시작할때 REQUIRES_NEW 옵션을 사용하면 된다.

        별도의 물리 트랜잭션 -> 서로 다른 DB 커넥션을 사용한다는 뜻이다.

        트랜잭션을 시작할때 REQUIRES_NEW 옵션과 함께 날리면 새로운 물리트랜잭션을 시작해버린다!


    스프링 트랜잭션 전파 8 - 다양한 전파 옵션
        실무에서는 거의 대부분 REQUIRED 옵션을 사용!!!
        아주 가끔 REQUIRES_NEW 사용
        나머진 거의...

        REQUIRED : 기존 트랜잭션이 없으면 생성, 있으면 참여!
        REQUIRES_NEW : 항상 새로운 트랜잭션을 생성한다.
        NOT_SUPPORT : 트랜잭션을 지원하지 않는다.
        MANDATORY : 의무사항, 트랜잭션이 반드시 있어야한다.
        NEVER : 트랜잭션을 지원하지 않는다. (기존 트랜잭션 부정)
        NESTED : 중첩 트랜잭션은 외부 트랜잭션의 영향을 받지만, 중첩 트랜잭션은 외부에 영향을 주지 않는다.

    정리
        모든 논리(내부) 트랜잭션이 커밋되어야 물리(외부,신규) 트랜잭션이 커밋된다.
        논리 트랜잭션이 하나라도 롤백된다면 결국 물리 트랜잭션도 롤백된다.

