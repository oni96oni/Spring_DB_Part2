데이터 접근 기술 - JPA
    JPA 시작

    ORM 개념 1 - SQL 중심적인 개발의 문제점
        애플리케이션은 객체
        데이터는 관계형 데이터베이스에

        자바객체 <-> SQL 을 무한 반복하게 된다.
        SQL에 의존적인 개발을 피하기 어렵다.

        RDBSM에 객체를 저장할때 객체를 SQL로 변환해야 한다. 개발자가 SQL 매퍼 역할을 해준다.
        상속, 연관관계, 데이터 타입, 데이터 식별방법 등에서 객체와 RDBMS의 차이가 발생한다.

        어떤 객체 저장시 일단 객체를 분해해야한다. 객체를 분해하면서 객체 그래프를 탐색하게 된다.

        엔티티 신뢰 문제, 객체 그래프 탐색 문제, 상속 문제, 연관관계 문제, 데이터 타입 문제, 데이터 식별 문제 등이 발생한다.

        물리적으로는 계층 분할이 되어있지만 진정한 의미의 계층 분할이 어렵다.

        객체를 자바 컬렉션에 저장 하듯이 db에 저장할 수는 없을까???
        JPA등장!

    ORM 개념 2 - JPA 소개
        기술 표준 - 표준안(인터페이스)
        ORM : Object Relational Mapping(객체 관계 매핑)
        객체랑 관계형 데이터베이스를 어떻게 매핑할것인가???

        ORM 프레임워크가 매핑역할을 해주는것!
        패러다임의 불일치를 해결!!!
            JPA와 상속, 연관관계, 객체 그래프 탐색,

        왜 JPA를 사용해야 하는가?
            SQL 중심적인 개발에서 객체 중심으로 개발
            생산성
            유지보수
            패러다임의 불일치
            성능
            데이터 접근 추상화와 벤더 독립성

        두가지를 잇는 하나의 계층에서는 캐시와 버퍼(버퍼링 write)관련되서 기능을 제공할 수 있다.

        지연로딩, 즉시로딩

    JPA 설정

    JPA 적용 1 - 개발
        ★★가장 중요한것은 객체와 테이블을 매핑하는것!
        JPA가 제공하는 애노테이션을 사용해서

        @Entity를 객체 클래스에다가 붙이면 JPA가 관리하는 엔티티가 된다. 이 애노테이션이 붙은 객체를 jpa에서는
        엔티티라고 부른다.
        @Id는 PK를 매핑한다.(변수에다가 적용)
        @GeneratedValue는 자동으로 생성되는 값을 매핑한다.(db에서 값을 장가해주면 IDENTITY전략을 넣어준다.)
        @Column : 컬럼 매핑, 이름과 길이 입력 가능, 부트와 통합해서 사용시 필드이름을 테이블 컬럼 명으로 변경할 때
        객체 필드의 카멜케이스를 테이블 컬럼의 언더스코어로 자동으로 변환해준다.
        @Table : 테이블 매핑, 이름 입력 가능 (객체명이랑 같으면 생략 가능)

        jpa는 public or protected로 된 기본 생성자가 필요하다. 꼭 넣어주어야 한다. (프록시 기술을 사용하기가 편해서)

        ★★jpa의 모든 데이터 변경은 @Transactional안에서 실행해야 한다!

        jpa는 EntityManager를 통해서 모든게 동작한다. 즉, 의존관계 주입을 받아주어야 한다.

        jpa설정은
        1. EntityManagerFactory
        2. JPA트랜잭션매니저
        3. 데이터소스
        등등 다양한 설정을 해야하지만 부트가 자동화 해준다

        부트의 자동설정은 JpaBaseConfiguration을 참고하면 된다.

        jpa에서 update되는로그 보려면 @Commit 넣어야 한다. 캐시기능 때문에

    JPA 적용 2 - 리포지토리 분석
        persist() : jpa에서 객체를 테이블에 저장할때는 엔티티 매니저가 제공하는 persist()를 사용한다.

        jpa는 커밋되는 시점에 변경된 엔티티 객체가 있는지 확인!
        변경된 경우 update sql을 실행한다!
        원본 객체를 캡쳐해서 스냅샷을 갖고있는데 커밋시점과 비교해준다.

        pk를 가지고 조회하는것이 아니라 복잡한 조건으로 데이터를 조회하려면 어떻게 해야할까? (동적쿼리문제 발생)
        jpql을 사용하면 된다.
        jpql은 sql과 문법이 비슷하다. (from, where, group by, join 등등) - 객체지향 쿼리 언어

        이렇게 jpa를 사용해도 동적쿼리문제가 발생한다.
        이럴때는 Querydsl을 사용하면 된다.
        Querydsl은 jpql을 생성해주는 라이브러리이다.

    JPA 적용 3 - 예외 변환
        jpa의 경우 예외가 발생하면 jpa예외가 발생한다.
        그런데 이 예외는 순수한 jpa 기술이어서 스프링과 관계가 없는 예외 이므로 스프링 예외로 변환해주어야 한다.

        스프링과 jpa를 함께 사용하는 경우 스프링은 jpa 변환기 (PersistenceExceptionTranslationPostProcessor)를 제공한다.
        예외 변환 aop 프록시는 관련 예외가 발생하면 jpa 변환기를 통해 발생한 예외를 스프링 데이터 접근 예외로 변환한다.

        예외 변환을 해주는 프록시

    정리
