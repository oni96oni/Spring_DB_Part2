스프링 트랜잭션 이해
    트랜잭션 적용 확인
        선언적 트랜잭션 방식은 트랜잭션 관련 코드가 눈에 보이지 않아 실제 적용되고 있는지 아닌지 확인하기 어렵다.
        어떻게 확인해볼까??

        @Transactional 애노테이션이 클래스나 메서드에 하나라도 있으면 트랜잭션AOP는 프록시를 만들어서
        스프링 컨테이너에 등록!

        실제 객체 대신 CGLIB을 스프링 빈에 등록한다.

        ★★핵심은 실제 객체 대신에 프록시가 스프링 컨테이너에 등록되었다는점!!

    트랜잭션 적용 위치
        우선순위는 어디에서 가지는가???

        @Transactional의 규칙
            1. ★스프링에서 우선순위는 항상 더 구체적이고 자세한 것이 높은 우선순위를 가진다!
            인터페이스보다 클래스, 클래스보다 메서드에 있는것이 더 높은 우선순위를 가진다.

            트랜잭션은 읽기와 쓰기 모두 가능한것이 디폴트 값!
            readOnly기능으로 읽기만 가능하게 할 수 있다.

            2. 클래스에 적용하면 그 클래스 안에 메서드에는 자동적용된다.

        인터페이스에도 트랜잭션 적용가능하지만 잘 사용하지 않는다.
        aop를 적용하는 방식에 따라서 적용이 되지 않는 경우도 있기때문!

    ★★★★★트랜잭션 AOP 주의 사항 - 프록시 내부 호출 1
        트랜잭션이 적용이 안되는경우?

        그래서 롤백이 적용이 안되어서 큰 문제로 발생!!

        트랜잭션 AOP는 기본적으로 프록시 방식의 AOP를 사용
        따라서 트랜잭션을 적용하려면 항상 프록시를 통해서 대상 객체를 호출해야 한다.
        프록시를 거치지 않고 대상 객체를 직접 호출하게 되면 AOP가 적용되지 않고, 트랜잭션도 적용 X

        ★★★대상 객체의 내부에서 메서드 호출이 발생하면 프록시를 거치지 않고 대상 객체를 직접 호출하는 문제가 발생한다.
        이런 경우 @Transactional이 있어도 트랜잭션이 적용되지 않는다.

        프록시가 잘 적용됬다는 증거 CGLIB 클래스가 생성되어있는지 확인해보자!

        this는 나 자신의 인스턴스 주소
        this.getClass()는 나 자신의 클래스 정보

        this로 나자신의 internal()을 호출해서 트랜잭션 적용이 되는 internal()이 아닌 자신의 internal()을 호출하게 된다.
        그래서 트랜잭션 적용이 안된것

        프록시 방식의 AOP 한계!!!
        프록시를 사용하면 메서드 내부 호출에 프록시를 적용할 수 없다!

    트랜잭션 AOP 주의 사항 - 프록시 내부 호출 2
        메서드 내부호출때문에 트랜잭션이 적용이 안되는 문제를 해결하기 위해
        internal()을 분리해보자

        public 메서드만 트랜잭션을 적용할 수 있다.(기본설정이 public)

        package-visible은 무엇???

        스프링이 public만 트랜잭션을 적용하도록 막아두었는데 왜그런걸까???
        애초에 트랜잭션을 걸고 싶지 않으니까 public이 아닌것이다! 라는 생각이 전제
        모든 메서드에 트랜잭션이 적용되면 의도하지 않은곳까지 과도하게 적용

        트랜잭션은 주로 비즈니스의 로직의 시작점에 걸기 때문에 외부에 열어주고 사용하는곳을 시작점으로 사용!

        참고로 public이 아닌곳에 @Transactional이 붙어있으면 예외가 발생하지는 않고 무시된다.

    트랜잭션 AOP 주의 사항 - 초기화 시점
        스프링 초기화 시점에는 AOP가 적용되지 않았을 수 있다!

        초기화 코드에 @PostConstruct와 @Transactional을 같이 사용하면
        초기화 코드에는 트랜잭션이 적용되지 않는다.

        초기화 코드가 먼저 호출되고 그 다음에 트랜잭션 AOP가 적용되기 때문!!!
        트랜잭션이 시작하고 끝을 내주어야 정상적인 흐름

        확실한 해결방안은

        ApplicationReadyEvent를 사용하는 것이다.
        ★이 이벤트는 트랜잭션 AOP를 포함한 스프링이 컨테이너가 완전히 생성되고 난 다음에 이벤트가 붙은 메서드를 호출해준다.
        따라서 init2()는 트랜잭션이 적용된걸 확인할 수 있다.

    트랜잭션 옵션 소개
        트랜잭션 사용은 어떤 트랜잭션 매니저를 사용할지 알아야 한다!
        @Transational에서도 트랜잭션 프록시가 사용할 트랜잭션 매니저를 지정해 주어야 한다.
        생략하면 기본으로 등록된 트랜잭션 매니저를 사용하기 때문에 생략
        사용하는 트랜잭션 매니저가 둘 이상이 될때는 이름 지정하여 구분 필수!

        rollbackFor
        noRollbackFor
        propagation
        isolation : 격리 레벨
        timeout : 트랜잭션 수행 시간에 대한 타임아웃을 초단위로 지정
        label
        readOnly : 읽기 전용 트랜잭션으로 설정(등록, 수정, 삭제가 안된다.)
            프레임워크, JDBC 드라이버, 데이터베이스에서 사용된다.

    예외와 트랜잭션 커밋, 롤백 - 기본
        예외가 발생 내부에서 처리못하고 트랜잭션 범위 밖으로 넘어가면??

        체크예외는 트랜잭션 범위 밖으로 넘어가면 커밋
        런타임(언체크) 예외는 트랜잭션 범위 밖으로 넘어가면 롤백

    예외와 트랜잭션 커밋, 롤백 - 활용

